function [ BFormatOut ] = bformat_rot_tilt_tumble( BFormatSig, rot, tilt, tumble )
%BFORMAT_ROT_TILT_TUMBLE Rotate, tilt, and then tumble a B-Format signal
%   
% bformat_rot_tilt_tumble( BFormatSig, rot, tilt, tumble )
%   Rotates the input B-Format signal BFormatSig by rot radians (around Z
%   axis) followed by tilting by tilt radians (around X axis) and then
%   tumbling by tumble radians (around Y axis). 
%
%   BFormatSig must be a 2-dimensional matrix where there are either
%   3 (W X Y) or 4 (W X Y Z) columns.  The number of rows is the number of
%   samples.
%
%   rot, tilt and tumble must all be scalar real values.
%
%   The returned matrix always has 4 columns (channels W, X, Y, and Z
%   respectively) and is the same length as BFormatSig.

if((ndims(BFormatSig)~=2) || ((size(BFormatSig, 2)~=3) && (size(BFormatSig, 2)~=4)))
    error ('BFormatSig is not the correct dimensions');
end

if(~isscalar(rot) || ~isreal(rot) || ~isscalar(tilt) ...
    || ~isreal(tilt) || ~isscalar(tumble) || ~isreal(tumble))

    error ('rot, tilt and tumble must be real scalar values');
end

% Calculate output by multiplying input by a matrix, depending on number of
% input channels (ie WXY or WXYZ)
% NOTE: there is a transpose at the end of the coefficient matrix to group
% the coefficients for each output signal together
if((size(BFormatSig, 2)==3))
    BFormatOut = BFormatSig * [...
        ... % W coefficients
        1   ...
        0   ...
        0;  ...
        ... % X Coefficients
        0   ...
        cos(rot) * cos(tumble) - sin(rot) * sin(tilt) * sin(tumble) ... 
        -sin(rot) * cos(tumble) - cos(rot) * sin(tilt) * sin(tumble); ...
        ... % Y coefficients
        0   ...
        sin(rot) * cos(tilt)    ...
        cos(rot) * cos(tilt);    ...
        ... % Z coefficients
        0   ...
        cos(rot) * sin(tumble) + sin(rot) * sin(tilt) * cos(tumble) ...
        -sin(rot) * sin(tumble) + cos(rot) * sin(tilt) * cos(tumble)]';    
else
    BFormatOut = BFormatSig * [...
        ... % W coefficients
        1   ...
        0   ...
        0   ...
        0;  ...
        ... % X Coefficients
        0   ...
        cos(rot) * cos(tumble) - sin(rot) * sin(tilt) * sin(tumble) ... 
        -sin(rot) * cos(tumble) - cos(rot) * sin(tilt) * sin(tumble) ...
        -cos(tilt) * sin(tumble);   ...
        ... % Y coefficients
        0   ...
        sin(rot) * cos(tilt)    ...
        cos(rot) * cos(tilt)    ...
        -sin(tilt); ...
        ... % Z coefficients
        0   ...
        cos(rot) * sin(tumble) + sin(rot) * sin(tilt) * cos(tumble) ...
        -sin(rot) * sin(tumble) + cos(rot) * sin(tilt) * cos(tumble) ...
        cos(tilt) * cos(tumble)]';
end
